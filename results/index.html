<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
 font: 10px sans-serif;
}

.axis path,
.axis line {
 fill: none;
 stroke: #000;
 shape-rendering: crispEdges;
}

.grid path,
.grid line {
 fill: none;
 stroke: rgba(0, 0, 0, 0.25);
 shape-rendering: crispEdges;
}

.x.axis path {
 display: none;
}

.line {
 fill: none;
 stroke-width: 2.5px;
}

  </style>
  <body>
  <script src="http://d3js.org/d3.v3.js"></script>
  <script>

d3.json("data.json", (error, data) => {
  const chart = createChart(data).xlabel("Count").ylabel("Time");
  const svg = d3.select("body").append("svg").datum(data).call(chart);
});

function createChart(data) {
  let width = 900;
  let height = 700;
  const chart = selection => {
    selection.each(function(datasets) {
      const margin = {top: 20, right: 80, bottom: 30, left: 100};
      const innerwidth = width - margin.left - margin.right;
      const innerheight = height - margin.top - margin.bottom;

      const x_scale = d3.scale
        .linear()
        .range([0, innerwidth])
        .domain([d3.min(datasets, d => d3.min(d.x)), d3.max(datasets, d => d3.max(d.x))]);

      const y_scale = d3.scale
        .linear()
        .range([innerheight, 0])
        .domain([d3.min(datasets, d => d3.min(d.y)), d3.max(datasets, d => d3.max(d.y))]);

      const color_scale = d3.scale
        .category10()
        .domain(d3.range(datasets.length));

      const x_axis = d3.svg.axis()
        .scale(x_scale)
        .orient("bottom");

      const y_axis = d3.svg.axis()
        .scale(y_scale)
        .orient("left");

      const x_grid = d3.svg.axis()
        .scale(x_scale)
        .orient("bottom")
        .tickSize(-innerheight)
        .tickFormat("");

      const y_grid = d3.svg.axis()
        .scale(y_scale)
        .orient("left")
        .tickSize(-innerwidth)
        .tickFormat("");

      const draw_line = d3.svg.line()
        .interpolate("basis")
        .x(d => x_scale(d[0]))
        .y(d => y_scale(d[1]));

      const svg = d3.select(this)
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      svg.append("g")
        .attr("class", "x grid")
        .attr("transform", "translate(0," + innerheight + ")")
        .call(x_grid);
      svg.append("g")
        .attr("class", "y grid")
        .call(y_grid);
      svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + innerheight + ")")
        .call(x_axis)
        .append("text")
        .attr("dy", "-.71em")
        .attr("x", innerwidth)
        .style("text-anchor", "end")
        .text(xlabel);
      svg.append("g")
        .attr("class", "y axis")
        .call(y_axis)
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", "0.71em")
        .style("text-anchor", "end")
        .text(ylabel);
      const data_lines = svg.selectAll(".d3_xy_chart_line")
        .data(datasets.map(d => d3.zip(d.x, d.y)))
        .enter().append("g")
        .attr("class", "d3_xy_chart_line");
      data_lines.append("path")
        .attr("class", "line")
        .attr("d", d => draw_line(d))
        .attr("stroke", (_, i) => color_scale(i));
      data_lines.append("text")
        .datum((d, i) => ({name: datasets[i].label, final: d[d.length-1]}))
        .attr("transform", d => ("translate(" + x_scale(d.final[0]) + "," + y_scale(d.final[1]) + ")" ))
        .attr("x", 3)
        .attr("dy", ".35em")
        .attr("fill", (_, i) => color_scale(i))
        .text(d => d.name);
    });
  }

  chart.width = value => {
    if (!arguments.length) return width;
    width = value;
    return chart;
  };
  chart.height = value => {
    if (!arguments.length) return height;
    height = value;
    return chart;
  };
  chart.xlabel = value => {
    if(!arguments.length) return xlabel;
    xlabel = value;
    return chart;
  };
  chart.ylabel = value => {
    if(!arguments.length) return ylabel;
    ylabel = value;
    return chart;
  };
  return chart;
}
</script>
